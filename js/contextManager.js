export class ContextManager {
    constructor() {
        this.context = {
            currentChapter: 0,
            globalSummary: "The story begins.",
            recentChapters: [] // Stores last 25 chapter summaries
        };
    }

    /**
     * Loads context from a parsed JSON object (from file upload).
     * @param {Object} jsonContext
     */
    loadContext(jsonContext) {
        if (!jsonContext) return;

        // Validation to ensure structure exists
        this.context = {
            currentChapter: jsonContext.currentChapter || 0,
            globalSummary: jsonContext.globalSummary || "",
            recentChapters: Array.isArray(jsonContext.recentChapters) ? jsonContext.recentChapters : []
        };
        console.log("Context loaded:", this.context);
    }

    /**
     * Returns the full context object for downloading.
     */
    getContextData() {
        return this.context;
    }

    /**
     * Returns a string representation of the context for the Architect.
     */
    getContextSummary() {
        const recentText = this.context.recentChapters
            .map(c => `Chapter ${c.number}: ${c.summary}`)
            .join("\n");

        return `
Previous Story Summary: ${this.context.globalSummary}

Recent Events:
${recentText}
        `.trim();
    }

    /**
     * Updates the context after a chapter is generated.
     * @param {number} chapterNum
     * @param {string} chapterSummary - Generated by Architect
     */
    updateContext(chapterNum, chapterSummary) {
        this.context.currentChapter = parseInt(chapterNum);

        // Add to recent chapters
        this.context.recentChapters.push({
            number: chapterNum,
            summary: chapterSummary
        });

        // Sort by chapter number just in case
        this.context.recentChapters.sort((a, b) => a.number - b.number);

        // Pruning logic: If we have > 25 chapters in the buffer
        if (this.context.recentChapters.length > 25) {
            this.pruneContext();
        }
    }

    /**
     * Compresses the oldest chapters into the global summary.
     * In a real app, this might call an LLM to summarize.
     * Here, we'll append the text to keep it simple but functional.
     */
    pruneContext() {
        console.log("Pruning context...");
        const chaptersToArchive = this.context.recentChapters.slice(0, -25); // Get the ones overflowing
        this.context.recentChapters = this.context.recentChapters.slice(-25); // Keep last 25

        const archiveText = chaptersToArchive
            .map(c => `[Ch.${c.number}] ${c.summary}`)
            .join(" ");

        this.context.globalSummary += " " + archiveText;

        // Limit global summary length roughly if it gets too huge (simple truncation for safety)
        if (this.context.globalSummary.length > 5000) {
            this.context.globalSummary = "..." + this.context.globalSummary.slice(-5000);
        }
    }
}
